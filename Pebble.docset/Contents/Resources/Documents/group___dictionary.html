<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Pebble SDK: Dictionary</title>
  <link href='bootstrap.css' media='screen' rel='stylesheet' type='text/css' />
  <link href='pebble-developer.css' media='screen' rel='stylesheet' type='text/css' />
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
  <link href="stylesheet.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-30638158-4']);
    _gaq.push(['_trackPageview']);
    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
</head>
<body>
  <div id="top" ><!-- do not remove this div, it is closed by doxygen! -->
    <div class="navbar navbar-inverse ">
      <div class="navbar-inner">
        <div class="container">
          <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <div class="nav-collapse collapse">
            <ul class="nav">
              <li><a class="first" href="#"><span></span></a></li>
              <li><a href="http://developer.getpebble.com/">Develop for Pebble</a></li>
            </ul>
            <ul class="nav pull-right">
              <li class="doc-nav-searchbox">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</li>
              <li><a href="http://forums.getpebble.com/">Forum</a></li>
              <li><a href="http://developer.getpebble.com/2/api-reference/modules.html">API Documentation</a></li>
              <li><a href="http://developer.getpebble.com/2/">Guides</a></li>
              <li><a href="http://developer.getpebble.com/blog/">Developer Blog</a></li>
            </ul>
          </div>
        </div>
      </div>
    </div>
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___dictionary.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Dictionary<div class="ingroups"><a class="el" href="group___foundation.html">Foundation</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Data serialization utilities. </p>
<p>Data residing in different parts of Pebble memory (RAM) may need to be gathered and assembled into a single continuous block for transport over the network via Bluetooth. The process of gathering and assembling this continuous block of data is called serialization.</p>
<p>You use data serialization utilities, like Dictionary, <a class="el" href="group___dictionary.html#struct_tuple" title="Data structure for one serialized key/value tuple. ">Tuple</a> and <a class="el" href="group___dictionary.html#struct_tuplet" title="Non-serialized, template data structure for a key/value pair. For strings and byte arrays...">Tuplet</a> data structures and accompanying functions, to accomplish this task. No transformations are performed on the actual data, however. These Pebble utilities simply help assemble the data into one continuous buffer according to a specific format.</p>
<p><a class="el" href="group___app_message.html">AppMessage</a> uses these utilities&ndash;in particular, Dictionary&ndash;to send information between mobile and Pebble watchapps.</p>
<h3>Writing key/value pairs</h3>
<p>To write two key/value pairs, without using Tuplets, you would do this: </p>
<div class="fragment"><div class="line"><span class="comment">// Byte array + key:</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a> SOME_DATA_KEY = 0xb00bf00b;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> uint8_t data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};</div>
<div class="line"></div>
<div class="line"><span class="comment">// CString + key:</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a> SOME_STRING_KEY = 0xabbababe;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">string</span> = <span class="stringliteral">&quot;Hello World&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Calculate the buffer size that is needed for the final Dictionary:</span></div>
<div class="line"><span class="keyword">const</span> uint8_t key_count = 2;</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a> size = <a class="code" href="group___dictionary.html#ga0551d069624fb5bfc066fecfa4153bde">dict_calc_buffer_size</a>(key_count, <span class="keyword">sizeof</span>(data),</div>
<div class="line">                                            <a class="code" href="group___standard_string.html#ga008e171a518fe0e0352f31b245e03875">strlen</a>(<span class="keywordtype">string</span>) + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Stack-allocated buffer in which to create the Dictionary:</span></div>
<div class="line">uint8_t buffer[size];</div>
<div class="line"></div>
<div class="line"><span class="comment">// Iterator variable, keeps the state of the creation serialization process:</span></div>
<div class="line"><a class="code" href="group___dictionary.html#struct_dictionary_iterator">DictionaryIterator</a> iter;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Begin:</span></div>
<div class="line"><a class="code" href="group___dictionary.html#ga9ec44fce51a2ce464a954b2bdd240ded">dict_write_begin</a>(&amp;iter, buffer, <span class="keyword">sizeof</span>(buffer));</div>
<div class="line"><span class="comment">// Write the Data:</span></div>
<div class="line"><a class="code" href="group___dictionary.html#ga30091feef740732d5d6bc3cf2312642a">dict_write_data</a>(&amp;iter, SOME_DATA_KEY, data, <span class="keyword">sizeof</span>(data));</div>
<div class="line"><span class="comment">// Write the CString:</span></div>
<div class="line"><a class="code" href="group___dictionary.html#ga015dfe89d0ee2f8b4e16ddda21bcf556">dict_write_cstring</a>(&amp;iter, SOME_STRING_KEY, <span class="keywordtype">string</span>);</div>
<div class="line"><span class="comment">// End:</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a> final_size = <a class="code" href="group___dictionary.html#ga3eb27175dd477e85ddd6add9bd1f8989">dict_write_end</a>(&amp;iter);</div>
<div class="line"></div>
<div class="line"><span class="comment">// buffer now contains the serialized information</span></div>
</div><!-- fragment --><h3>Reading key/value pairs</h3>
<p>To iterate over the key/value pairs in the dictionary that was created in the previous example code, you would do this:</p>
<div class="fragment"><div class="line"><a class="code" href="group___dictionary.html#struct_tuple">Tuple</a> *tuple = <a class="code" href="group___dictionary.html#ga53e2f0be9656c1331b96dd9a21684cda">dict_read_begin_from_buffer</a>(&amp;iter, buffer, final_size);</div>
<div class="line"><span class="keywordflow">while</span> (tuple) {</div>
<div class="line">  <span class="keywordflow">switch</span> (tuple-&gt;<a class="code" href="group___dictionary.html#ae0a5c5233ca231aa7c1a368d340a97c0">key</a>) {</div>
<div class="line">    <span class="keywordflow">case</span> SOME_DATA_KEY:</div>
<div class="line">      foo(tuple-&gt;<a class="code" href="group___dictionary.html#acdb1b65409ef15374515d86b90445efd">value</a>-&gt;data, tuple-&gt;<a class="code" href="group___dictionary.html#ac83219d80bf6300b0afe53d5b30955a9">length</a>);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> SOME_STRING_KEY:</div>
<div class="line">      bar(tuple-&gt;<a class="code" href="group___dictionary.html#acdb1b65409ef15374515d86b90445efd">value</a>-&gt;cstring);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">  }</div>
<div class="line">  tuple = <a class="code" href="group___dictionary.html#ga0eec986d580dbf197753dff6aab3dae4">dict_read_next</a>(&amp;iter);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="el" href="group___dictionary.html#struct_tuple" title="Data structure for one serialized key/value tuple. ">Tuple</a> and <a class="el" href="group___dictionary.html#struct_tuplet" title="Non-serialized, template data structure for a key/value pair. For strings and byte arrays...">Tuplet</a> data structures</h3>
<p>To understand the difference between <a class="el" href="group___dictionary.html#struct_tuple" title="Data structure for one serialized key/value tuple. ">Tuple</a> and <a class="el" href="group___dictionary.html#struct_tuplet" title="Non-serialized, template data structure for a key/value pair. For strings and byte arrays...">Tuplet</a> data structures: <a class="el" href="group___dictionary.html#struct_tuple" title="Data structure for one serialized key/value tuple. ">Tuple</a> is the header for a serialized key/value pair, while <a class="el" href="group___dictionary.html#struct_tuplet" title="Non-serialized, template data structure for a key/value pair. For strings and byte arrays...">Tuplet</a> is a helper data structure that references the value you want to serialize. This data structure exists to make the creation of a Dictionary easier to write. Use this mnemonic to remember the difference: TupleT(emplate), the <a class="el" href="group___dictionary.html#struct_tuplet" title="Non-serialized, template data structure for a key/value pair. For strings and byte arrays...">Tuplet</a> being a template to create a Dictionary with <a class="el" href="group___dictionary.html#struct_tuple" title="Data structure for one serialized key/value tuple. ">Tuple</a> structures.</p>
<p>For example: </p>
<div class="fragment"><div class="line"><a class="code" href="group___dictionary.html#struct_tuplet">Tuplet</a> pairs[] = {</div>
<div class="line">  TupletInteger(WEATHER_ICON_KEY, (uint8_t) 1),</div>
<div class="line">  TupletCString(WEATHER_TEMPERATURE_KEY, <span class="stringliteral">&quot;1234 Fahrenheit&quot;</span>),</div>
<div class="line">};</div>
<div class="line">uint8_t buffer[256];</div>
<div class="line"><a class="code" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a> size = <span class="keyword">sizeof</span>(buffer);</div>
<div class="line"><a class="code" href="group___dictionary.html#gaeaaca187fe71e6d2dd8a4eb4deec2069">dict_serialize_tuplets_to_buffer</a>(pairs, ARRAY_LENGTH(pairs), buffer, &amp;size);</div>
<div class="line"></div>
<div class="line"><span class="comment">// buffer now contains the serialized information</span></div>
</div><!-- fragment --> <h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga0551d069624fb5bfc066fecfa4153bde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a> dict_calc_buffer_size </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tuple_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the number of bytes that a dictionary will occupy, given one or more value lengths that need to be stored in the dictionary. </p>
<dl class="section note"><dt>Note</dt><dd>The formula to calculate the size of a Dictionary in bytes is: <pre>1 + (n * 7) + D1 + ... + Dn</pre> Where <code>n</code> is the number of Tuples in the Dictionary and <code>Dx</code> are the sizes of the values in the Tuples. The size of the Dictionary header is 1 byte. The size of the header for each <a class="el" href="group___dictionary.html#struct_tuple" title="Data structure for one serialized key/value tuple. ">Tuple</a> is 7 bytes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple_count</td><td>The total number of key/value pairs in the dictionary. </td></tr>
    <tr><td class="paramname">...</td><td>The sizes of each of the values that need to be stored in the dictionary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of bytes of storage needed. </dd></dl>

</div>
</div>
<a class="anchor" id="gad31424a83643adbfd9e84c4bd37e4627"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a> dict_calc_buffer_size_from_tuplets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___dictionary.html#struct_tuplet">Tuplet</a> *const&#160;</td>
          <td class="paramname"><em>tuplets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tuplets_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the number of bytes that a dictionary will occupy, given one or more Tuplets that need to be stored in the dictionary. </p>
<dl class="section note"><dt>Note</dt><dd>See <a class="el" href="group___dictionary.html#ga0551d069624fb5bfc066fecfa4153bde">dict_calc_buffer_size()</a> for the formula for the calculation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuplets</td><td>An array of Tuplets that need to be stored in the dictionary. </td></tr>
    <tr><td class="paramname">tuplets_count</td><td>The total number of Tuplets that follow. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of bytes of storage needed. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___dictionary.html#struct_tuplet" title="Non-serialized, template data structure for a key/value pair. For strings and byte arrays...">Tuplet</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3639dbedb6da3248e0c2b1c804368da2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___dictionary.html#struct_tuple">Tuple</a>* dict_find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___dictionary.html#struct_dictionary_iterator">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a>&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to find a <a class="el" href="group___dictionary.html#struct_tuple" title="Data structure for one serialized key/value tuple. ">Tuple</a> with specified key in a dictionary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Iterator to the dictionary to search in. </td></tr>
    <tr><td class="paramname">key</td><td>The key for which to find a <a class="el" href="group___dictionary.html#struct_tuple" title="Data structure for one serialized key/value tuple. ">Tuple</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a found <a class="el" href="group___dictionary.html#struct_tuple" title="Data structure for one serialized key/value tuple. ">Tuple</a>, or NULL if there was no <a class="el" href="group___dictionary.html#struct_tuple" title="Data structure for one serialized key/value tuple. ">Tuple</a> with the specified key. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8ab5934dba34043d2f3319e9ff9dcfc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a> dict_merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___dictionary.html#struct_dictionary_iterator">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a> *&#160;</td>
          <td class="paramname"><em>dest_max_size_in_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___dictionary.html#struct_dictionary_iterator">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>update_existing_keys_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___dictionary.html#ga99b02996e555fcbaa01c456501dfb384">DictionaryKeyUpdatedCallback</a>&#160;</td>
          <td class="paramname"><em>key_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges entries from another "source" dictionary into a "destination" dictionary. All Tuples from the source are written into the destination dictionary, while updating the exsting Tuples with matching keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dest</td><td>The destination dictionary to update </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dest_max_size_in_out</td><td>In: the maximum size of buffer backing <code>dest</code>. Out: the final size of the updated dictionary. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">source</td><td>The source dictionary of which its Tuples will be used to update dest. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">update_existing_keys_only</td><td>Specify True if only the existing keys in <code>dest</code> should be updated. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_callback</td><td>The callback that will be called for each <a class="el" href="group___dictionary.html#struct_tuple" title="Data structure for one serialized key/value tuple. ">Tuple</a> in the merged destination dictionary. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">context</td><td>Pointer to app specific data that will get passed in when <code>update_key_callback</code> is called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6">DICT_OK</a>, <a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2">DICT_INVALID_ARGS</a>, <a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04">DICT_NOT_ENOUGH_STORAGE</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga53e2f0be9656c1331b96dd9a21684cda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___dictionary.html#struct_tuple">Tuple</a>* dict_read_begin_from_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___dictionary.html#struct_dictionary_iterator">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *const&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___standard_c.html#gabf6633e0fef9023e8a1e8d727f4023e1">uint16_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the dictionary iterator with a given buffer and size, in preparation of reading key/value tuples. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The dictionary iterator </td></tr>
    <tr><td class="paramname">buffer</td><td>The storage of the dictionary </td></tr>
    <tr><td class="paramname">size</td><td>The storage size of the dictionary </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first tuple in the dictionary, or NULL in case the dictionary was empty or if there was a parsing error. </dd></dl>

</div>
</div>
<a class="anchor" id="gaac0457f671cd0e4e9e539812f9a641f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___dictionary.html#struct_tuple">Tuple</a>* dict_read_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___dictionary.html#struct_dictionary_iterator">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the iterator back to the same state as a call to <a class="el" href="group___dictionary.html#ga53e2f0be9656c1331b96dd9a21684cda">dict_read_begin_from_buffer()</a> would do. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The dictionary iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first tuple in the dictionary, or NULL in case the dictionary was empty or if there was a parsing error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0eec986d580dbf197753dff6aab3dae4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___dictionary.html#struct_tuple">Tuple</a>* dict_read_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___dictionary.html#struct_dictionary_iterator">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Progresses the iterator to the next key/value pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The dictionary iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next tuple in the dictionary, or NULL in case the end has been reached or if there was a parsing error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6de59736dc56fcda7e4df30ba10ba0cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a> dict_serialize_tuplets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___dictionary.html#ga41471ee8f71754cbaf16fd0ea27c5b58">DictionarySerializeCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___dictionary.html#struct_tuplet">Tuplet</a> *const&#160;</td>
          <td class="paramname"><em>tuplets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tuplets_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function that takes a list of Tuplets from which a dictionary will be serialized, ready to transmit or store. </p>
<dl class="section note"><dt>Note</dt><dd>The callback will be called before the function returns, so the data that that <code>context</code> points to, can be stack allocated. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback that will be called with the serialized data of the generated dictionary. </td></tr>
    <tr><td class="paramname">context</td><td>Pointer to any application specific data that gets passed into the callback. </td></tr>
    <tr><td class="paramname">tuplets</td><td>An array of Tuplets that need to be serialized into the dictionary. </td></tr>
    <tr><td class="paramname">tuplets_count</td><td>The number of tuplets that follow. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6">DICT_OK</a>, <a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04">DICT_NOT_ENOUGH_STORAGE</a> or <a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2">DICT_INVALID_ARGS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaeaaca187fe71e6d2dd8a4eb4deec2069"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a> dict_serialize_tuplets_to_buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___dictionary.html#struct_tuplet">Tuplet</a> *const&#160;</td>
          <td class="paramname"><em>tuplets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tuplets_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a> *&#160;</td>
          <td class="paramname"><em>size_in_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function that takes an array of Tuplets and serializes them into a dictionary with a given buffer and size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">tuplets</td><td>The array of tuplets </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tuplets_count</td><td>The number of tuplets in the array </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>The buffer in which to write the serialized dictionary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size_in_out</td><td>The available buffer size in bytes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size_in_out</td><td>The number of bytes written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6">DICT_OK</a>, <a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04">DICT_NOT_ENOUGH_STORAGE</a> or <a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2">DICT_INVALID_ARGS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga93526111e666de9fdca7276f6ca73c5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a> dict_serialize_tuplets_to_buffer_with_iter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___dictionary.html#struct_dictionary_iterator">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___dictionary.html#struct_tuplet">Tuplet</a> *const&#160;</td>
          <td class="paramname"><em>tuplets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tuplets_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a> *&#160;</td>
          <td class="paramname"><em>size_in_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes an array of Tuplets into a dictionary with a given buffer and size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">iter</td><td>The dictionary iterator </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tuplets</td><td>The array of tuplets </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tuplets_count</td><td>The number of tuplets in the array </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>The buffer in which to write the serialized dictionary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size_in_out</td><td>The available buffer size in bytes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size_in_out</td><td>The number of bytes written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6">DICT_OK</a>, <a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04">DICT_NOT_ENOUGH_STORAGE</a> or <a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2">DICT_INVALID_ARGS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa7fbb0db218e7e6f59eccfa2650fd645"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a> dict_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___dictionary.html#struct_dictionary_iterator">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the size of data that has been written to the dictionary. AKA, the "dictionary size". Note that this is most likely different than the size of the backing storage/backing buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The dictionary iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of bytes which have been written to the dictionary. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9ec44fce51a2ce464a954b2bdd240ded"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a> dict_write_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___dictionary.html#struct_dictionary_iterator">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___standard_c.html#gabf6633e0fef9023e8a1e8d727f4023e1">uint16_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the dictionary iterator with a given buffer and size, resets and empties it, in preparation of writing key/value tuples. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The dictionary iterator </td></tr>
    <tr><td class="paramname">buffer</td><td>The storage of the dictionary </td></tr>
    <tr><td class="paramname">size</td><td>The storage size of the dictionary </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6">DICT_OK</a>, <a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04">DICT_NOT_ENOUGH_STORAGE</a> or <a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2">DICT_INVALID_ARGS</a> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___dictionary.html#ga0551d069624fb5bfc066fecfa4153bde" title="Calculates the number of bytes that a dictionary will occupy, given one or more value lengths that ne...">dict_calc_buffer_size</a> </dd>
<dd>
<a class="el" href="group___dictionary.html#ga3eb27175dd477e85ddd6add9bd1f8989" title="End a series of writing operations to a dictionary. This must be called before reading back from the ...">dict_write_end</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga015dfe89d0ee2f8b4e16ddda21bcf556"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a> dict_write_cstring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___dictionary.html#struct_dictionary_iterator">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>cstring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a key with a C string value pair to the dictionary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The dictionary iterator </td></tr>
    <tr><td class="paramname">key</td><td>The key </td></tr>
    <tr><td class="paramname">cstring</td><td>Pointer to the zero-terminated C string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6">DICT_OK</a>, <a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04">DICT_NOT_ENOUGH_STORAGE</a> or <a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2">DICT_INVALID_ARGS</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The string will be copied into the backing storage of the dictionary. </dd>
<dd>
There is <em>no</em> checking for duplicate keys. </dd></dl>

</div>
</div>
<a class="anchor" id="ga30091feef740732d5d6bc3cf2312642a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a> dict_write_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___dictionary.html#struct_dictionary_iterator">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___standard_c.html#gabf6633e0fef9023e8a1e8d727f4023e1">uint16_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a key with a byte array value pair to the dictionary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The dictionary iterator </td></tr>
    <tr><td class="paramname">key</td><td>The key </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the byte array </td></tr>
    <tr><td class="paramname">size</td><td>Length of the byte array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6">DICT_OK</a>, <a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04">DICT_NOT_ENOUGH_STORAGE</a> or <a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2">DICT_INVALID_ARGS</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The data will be copied into the backing storage of the dictionary. </dd>
<dd>
There is <em>no</em> checking for duplicate keys. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3eb27175dd477e85ddd6add9bd1f8989"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a> dict_write_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___dictionary.html#struct_dictionary_iterator">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End a series of writing operations to a dictionary. This must be called before reading back from the dictionary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The dictionary iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size in bytes of the finalized dictionary, or 0 if the parameters were invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8c4675ccaca8f466f87efb43ae2b2da5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a> dict_write_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___dictionary.html#struct_dictionary_iterator">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>integer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>width_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_signed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a key with an integer value pair to the dictionary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The dictionary iterator </td></tr>
    <tr><td class="paramname">key</td><td>The key </td></tr>
    <tr><td class="paramname">integer</td><td>Pointer to the integer value </td></tr>
    <tr><td class="paramname">width_bytes</td><td>The width of the integer value </td></tr>
    <tr><td class="paramname">is_signed</td><td>Whether the integer's type is signed or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6">DICT_OK</a>, <a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04">DICT_NOT_ENOUGH_STORAGE</a> or <a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2">DICT_INVALID_ARGS</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>There is <em>no</em> checking for duplicate keys. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5ed3421ff8e8deda77545aae7d63f191"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a> dict_write_tuplet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___dictionary.html#struct_dictionary_iterator">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___dictionary.html#struct_tuplet">Tuplet</a> *const&#160;</td>
          <td class="paramname"><em>tuplet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a <a class="el" href="group___dictionary.html#struct_tuplet" title="Non-serialized, template data structure for a key/value pair. For strings and byte arrays...">Tuplet</a> and writes the resulting <a class="el" href="group___dictionary.html#struct_tuple" title="Data structure for one serialized key/value tuple. ">Tuple</a> into a dictionary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The dictionary iterator </td></tr>
    <tr><td class="paramname">tuplet</td><td>The <a class="el" href="group___dictionary.html#struct_tuplet" title="Non-serialized, template data structure for a key/value pair. For strings and byte arrays...">Tuplet</a> describing the key/value pair to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6">DICT_OK</a>, <a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04">DICT_NOT_ENOUGH_STORAGE</a> or <a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2">DICT_INVALID_ARGS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8fab9c8ce0fdae44a891c6784f4d38a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a> dict_write_uint8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___dictionary.html#struct_dictionary_iterator">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a key with an unsigned, 8-bit integer value pair to the dictionary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The dictionary iterator </td></tr>
    <tr><td class="paramname">key</td><td>The key </td></tr>
    <tr><td class="paramname">value</td><td>The unsigned, 8-bit integer value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6">DICT_OK</a>, <a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04">DICT_NOT_ENOUGH_STORAGE</a> or <a class="el" href="group___dictionary.html#ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2">DICT_INVALID_ARGS</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>There is <em>no</em> checking for duplicate keys. </dd>
<dd>
There are counterpart functions for different signedness and widths, <code>dict_write_uint16()</code>, <code>dict_write_uint32()</code>, <code>dict_write_int8()</code>, <code>dict_write_int16()</code> and <code>dict_write_int32()</code>. The documentation is not repeated for brevity's sake. </dd></dl>

</div>
</div>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="struct_dictionary_iterator" id="struct_dictionary_iterator"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct DictionaryIterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>An iterator can be used to iterate over the key/value tuples in an existing dictionary, using <a class="el" href="group___dictionary.html#ga53e2f0be9656c1331b96dd9a21684cda">dict_read_begin_from_buffer()</a>, <a class="el" href="group___dictionary.html#gaac0457f671cd0e4e9e539812f9a641f2">dict_read_first()</a> and <a class="el" href="group___dictionary.html#ga0eec986d580dbf197753dff6aab3dae4">dict_read_next()</a>. An iterator can also be used to append key/value tuples to a dictionary, for example using <a class="el" href="group___dictionary.html#ga30091feef740732d5d6bc3cf2312642a">dict_write_data()</a> or <a class="el" href="group___dictionary.html#ga015dfe89d0ee2f8b4e16ddda21bcf556">dict_write_cstring()</a>. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a92ab563836acb6ea6af20c0f1c8f4981"></a><a class="el" href="group___dictionary.html#struct_tuple">Tuple</a> *</td>
<td class="fieldname">
cursor</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a425cdb246d7c88aee09763888979a3a7"></a>Dictionary *</td>
<td class="fieldname">
dictionary</td>
<td class="fielddoc">
The dictionary being iterated. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a8c032e6b049c07cef73c42cf67bfcc6c"></a>const void *</td>
<td class="fieldname">
end</td>
<td class="fielddoc">
Points to the first memory address after the last byte of the dictionary Points to the next <a class="el" href="group___dictionary.html#struct_tuple" title="Data structure for one serialized key/value tuple. ">Tuple</a> in the dictionary. Given the end of the Dictionary has not yet been reached: when writing, the next key/value pair will be written at the cursor. When reading, the next call to <a class="el" href="group___dictionary.html#ga0eec986d580dbf197753dff6aab3dae4">dict_read_next()</a> will return the cursor. </td></tr>
</table>

</div>
</div>
<a name="struct_tuple" id="struct_tuple"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Tuple</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Data structure for one serialized key/value tuple. </p>
<dl class="section note"><dt>Note</dt><dd>The structure is variable length! The length depends on the value data that the tuple contains. </dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae0a5c5233ca231aa7c1a368d340a97c0"></a><a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a></td>
<td class="fieldname">
key</td>
<td class="fielddoc">
The key. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ac83219d80bf6300b0afe53d5b30955a9"></a><a class="el" href="group___standard_c.html#gabf6633e0fef9023e8a1e8d727f4023e1">uint16_t</a></td>
<td class="fieldname">
length</td>
<td class="fielddoc">
The length of <code>.value</code> in bytes. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae2c621840b9fa7c2e7ef21074331d317"></a><a class="el" href="group___dictionary.html#gaf164f32d9bda6829f1738ef3fb2c6670">TupleType</a></td>
<td class="fieldname">
type:8</td>
<td class="fielddoc">
The type of data that the <code>.value</code> fields contains. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="acdb1b65409ef15374515d86b90445efd"></a>union <a class="el" href="group___dictionary.html#union_tuple_8value">Tuple</a></td>
<td class="fieldname">
value[]</td>
<td class="fielddoc">
The value itself. <p>The different union fields are provided for convenience, avoiding the need for manual casts. </p>
<dl class="section note"><dt>Note</dt><dd>The array length is of incomplete length on purpose, to facilitate variable length data and because a data length of zero is valid. </dd>
<dd>
<b>Important: The integers are little endian!</b> </dd></dl>
</td></tr>
</table>

</div>
</div>
<a name="union_tuple_8value" id="union_tuple_8value"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union Tuple.value</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The value itself. </p>
<p>The different union fields are provided for convenience, avoiding the need for manual casts. </p>
<dl class="section note"><dt>Note</dt><dd>The array length is of incomplete length on purpose, to facilitate variable length data and because a data length of zero is valid. </dd>
<dd>
<b>Important: The integers are little endian!</b> </dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a045a170bdc8241264dfe8fda3d1d77ff"></a>char</td>
<td class="fieldname">
cstring[0]</td>
<td class="fielddoc">
The C-string value. Valid when <code>.type</code> is <a class="el" href="group___dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670a73c9d3384801aec20d36c732d9218dab">TUPLE_CSTRING</a>. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a59a6c49cfff82ce638c44fec9cd91ddb"></a>uint8_t</td>
<td class="fieldname">
data[0]</td>
<td class="fielddoc">
The byte array value. Valid when <code>.type</code> is <a class="el" href="group___dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670ad852031b350c69166303a05dbe294ec7">TUPLE_BYTE_ARRAY</a>. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ace80d5ec65b1d2a2f1049eadc100db23"></a>int16_t</td>
<td class="fieldname">
int16</td>
<td class="fielddoc">
The 16-bit signed integer value. Valid when <code>.type</code> is <a class="el" href="group___dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670ad691daf1df77095c1e19fe30b6cea5b4">TUPLE_INT</a> and <code>.length</code> is 2 byte. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a0241adbbd83925f051b694d40f02747f"></a>int32_t</td>
<td class="fieldname">
int32</td>
<td class="fielddoc">
The 32-bit signed integer value. Valid when <code>.type</code> is <a class="el" href="group___dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670ad691daf1df77095c1e19fe30b6cea5b4">TUPLE_INT</a> and <code>.length</code> is 4 byte. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a27c006cc56b1ba88f960cf8b5144fcac"></a>int8_t</td>
<td class="fieldname">
int8</td>
<td class="fielddoc">
The 8-bit signed integer value. Valid when <code>.type</code> is <a class="el" href="group___dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670ad691daf1df77095c1e19fe30b6cea5b4">TUPLE_INT</a> and <code>.length</code> is 1 byte. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aa00ef2ef85ff67b7b39339886f19044f"></a><a class="el" href="group___standard_c.html#gabf6633e0fef9023e8a1e8d727f4023e1">uint16_t</a></td>
<td class="fieldname">
uint16</td>
<td class="fielddoc">
The 16-bit unsigned integer value. Valid when <code>.type</code> is <a class="el" href="group___dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670a6802e5d267fdda619ffb13fc80d873fe">TUPLE_UINT</a> and <code>.length</code> is 2 byte. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a3de84ad0700f2a1571f633d399e1900e"></a><a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a></td>
<td class="fieldname">
uint32</td>
<td class="fielddoc">
The 32-bit unsigned integer value. Valid when <code>.type</code> is <a class="el" href="group___dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670a6802e5d267fdda619ffb13fc80d873fe">TUPLE_UINT</a> and <code>.length</code> is 4 byte. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a5f423e669d0a8f4ab7c4c3e6da27161a"></a>uint8_t</td>
<td class="fieldname">
uint8</td>
<td class="fielddoc">
The 8-bit unsigned integer value. Valid when <code>.type</code> is <a class="el" href="group___dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670a6802e5d267fdda619ffb13fc80d873fe">TUPLE_UINT</a> and <code>.length</code> is 1 byte. </td></tr>
</table>

</div>
</div>
<a name="struct_tuplet" id="struct_tuplet"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Tuplet</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Non-serialized, template data structure for a key/value pair. For strings and byte arrays, it only has a pointer to the actual data. For integers, it provides storage for integers up to 32-bits wide. The <a class="el" href="group___dictionary.html#struct_tuplet" title="Non-serialized, template data structure for a key/value pair. For strings and byte arrays...">Tuplet</a> data structure is useful when creating dictionaries from values that are already stored in arbitrary buffers. See also <a class="el" href="group___dictionary.html#struct_tuple">Tuple</a>, with is the header of a serialized key/value pair. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aeed75c4ebb6588258dc1b1165193eb1b"></a>union <a class="el" href="group___dictionary.html#union_tuplet_8____unnamed____">Tuplet</a></td>
<td class="fieldname">
__unnamed__</td>
<td class="fielddoc">
Anonymous union containing the reference to the <a class="el" href="group___dictionary.html#struct_tuplet" title="Non-serialized, template data structure for a key/value pair. For strings and byte arrays...">Tuplet</a>'s value, being either a byte array, c-string or integer. See documentation of <code>.bytes</code>, <code>.cstring</code> and <code>.integer</code> fields. <p>See documentation of <code>.bytes</code>, <code>.cstring</code> and <code>.integer</code> fields. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a0d335183753df2961b426478c17b553a"></a><a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a></td>
<td class="fieldname">
key</td>
<td class="fielddoc">
The key. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a1451fd4819f780d8877c0ac8d52151d2"></a><a class="el" href="group___dictionary.html#gaf164f32d9bda6829f1738ef3fb2c6670">TupleType</a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
The type of the <a class="el" href="group___dictionary.html#struct_tuplet" title="Non-serialized, template data structure for a key/value pair. For strings and byte arrays...">Tuplet</a>. This determines which of the struct fields in the anonymomous union are valid. </td></tr>
</table>

</div>
</div>
<a name="union_tuplet_8____unnamed____" id="union_tuplet_8____unnamed____"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union Tuplet.__unnamed__</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Anonymous union containing the reference to the <a class="el" href="group___dictionary.html#struct_tuplet" title="Non-serialized, template data structure for a key/value pair. For strings and byte arrays...">Tuplet</a>'s value, being either a byte array, c-string or integer. See documentation of <code>.bytes</code>, <code>.cstring</code> and <code>.integer</code> fields. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a4b3a6218bb3e3a7303e8a171a60fcf92"></a><a class="el" href="group___dictionary.html#struct_tuplet_8____unnamed_____8bytes">__unnamed__</a></td>
<td class="fieldname">
bytes</td>
<td class="fielddoc">
Valid when <code>.type.</code> is <a class="el" href="group___dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670ad852031b350c69166303a05dbe294ec7">TUPLE_BYTE_ARRAY</a>. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a59df64e03292f845a11befa53b2845d1"></a><a class="el" href="group___dictionary.html#struct_tuplet_8____unnamed_____8cstring">__unnamed__</a></td>
<td class="fieldname">
cstring</td>
<td class="fielddoc">
Valid when <code>.type.</code> is <a class="el" href="group___dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670a73c9d3384801aec20d36c732d9218dab">TUPLE_CSTRING</a>. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a157db7df530023575515d366c9b672e8"></a><a class="el" href="group___dictionary.html#struct_tuplet_8____unnamed_____8integer">__unnamed__</a></td>
<td class="fieldname">
integer</td>
<td class="fielddoc">
Valid when <code>.type.</code> is <a class="el" href="group___dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670ad691daf1df77095c1e19fe30b6cea5b4">TUPLE_INT</a> or <a class="el" href="group___dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670a6802e5d267fdda619ffb13fc80d873fe">TUPLE_UINT</a>. </td></tr>
</table>

</div>
</div>
<a name="struct_tuplet_8____unnamed_____8bytes" id="struct_tuplet_8____unnamed_____8bytes"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Tuplet.__unnamed__.bytes</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Valid when <code>.type.</code> is <a class="el" href="group___dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670ad852031b350c69166303a05dbe294ec7">TUPLE_BYTE_ARRAY</a>. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a8d777f385d3dfec8815d20f7496026dc"></a>const uint8_t *</td>
<td class="fieldname">
data</td>
<td class="fielddoc">
Pointer to the data. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a2fa47f7c65fec19cc163b195725e3844"></a>const <a class="el" href="group___standard_c.html#gabf6633e0fef9023e8a1e8d727f4023e1">uint16_t</a></td>
<td class="fieldname">
length</td>
<td class="fielddoc">
Length of the data. </td></tr>
</table>

</div>
</div>
<a name="struct_tuplet_8____unnamed_____8cstring" id="struct_tuplet_8____unnamed_____8cstring"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Tuplet.__unnamed__.cstring</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Valid when <code>.type.</code> is <a class="el" href="group___dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670a73c9d3384801aec20d36c732d9218dab">TUPLE_CSTRING</a>. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a8d777f385d3dfec8815d20f7496026dc"></a>const char *</td>
<td class="fieldname">
data</td>
<td class="fielddoc">
Pointer to the c-string data. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a2fa47f7c65fec19cc163b195725e3844"></a>const <a class="el" href="group___standard_c.html#gabf6633e0fef9023e8a1e8d727f4023e1">uint16_t</a></td>
<td class="fieldname">
length</td>
<td class="fielddoc">
Length of the c-string, including terminating zero. </td></tr>
</table>

</div>
</div>
<a name="struct_tuplet_8____unnamed_____8integer" id="struct_tuplet_8____unnamed_____8integer"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Tuplet.__unnamed__.integer</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Valid when <code>.type.</code> is <a class="el" href="group___dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670ad691daf1df77095c1e19fe30b6cea5b4">TUPLE_INT</a> or <a class="el" href="group___dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670a6802e5d267fdda619ffb13fc80d873fe">TUPLE_UINT</a>. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="addecebdea58b5f264d27f1f7909bab74"></a><a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a></td>
<td class="fieldname">
storage</td>
<td class="fielddoc">
Actual storage of the integer. The signedness can be derived from the <code>.type</code> value. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aeaae26a6fb20ed3ef54fb23bfa0b1fcc"></a>const <a class="el" href="group___standard_c.html#gabf6633e0fef9023e8a1e8d727f4023e1">uint16_t</a></td>
<td class="fieldname">
width</td>
<td class="fielddoc">
Width of the integer. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga99b02996e555fcbaa01c456501dfb384"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* DictionaryKeyUpdatedCallback)(const <a class="el" href="group___standard_c.html#gad53b3f685c3f3153f35ec87ea6f349d1">uint32_t</a> key, const <a class="el" href="group___dictionary.html#struct_tuple">Tuple</a> *new_tuple, const <a class="el" href="group___dictionary.html#struct_tuple">Tuple</a> *old_tuple, void *context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the callback used in <a class="el" href="group___dictionary.html#ga8ab5934dba34043d2f3319e9ff9dcfc1">dict_merge()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key that is being updated. </td></tr>
    <tr><td class="paramname">new_tuple</td><td>The new tuple. The tuple points to the actual, updated destination dictionary or NULL_TUPLE in case there was an error (e.g. backing buffer was too small). Therefore the <a class="el" href="group___dictionary.html#struct_tuple" title="Data structure for one serialized key/value tuple. ">Tuple</a> can be used after the callback returns, until the destination dictionary storage is free'd (by the application itself). </td></tr>
    <tr><td class="paramname">old_tuple</td><td>The values that will be replaced with <code>new_tuple</code>. The key, value and type will be equal to the previous tuple in the old destination dictionary, however the `old_tuple points to a stack-allocated copy of the old data. </td></tr>
    <tr><td class="paramname">context</td><td>Pointer to application specific data The storage backing <code>old_tuple</code> can only be used during the callback and will no longer be valid after the callback returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___dictionary.html#ga8ab5934dba34043d2f3319e9ff9dcfc1" title="Merges entries from another &quot;source&quot; dictionary into a &quot;destination&quot; dictionary. All Tuples from the ...">dict_merge</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga41471ee8f71754cbaf16fd0ea27c5b58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* DictionarySerializeCallback)(const uint8_t *const data, const <a class="el" href="group___standard_c.html#gabf6633e0fef9023e8a1e8d727f4023e1">uint16_t</a> size, void *context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for <a class="el" href="group___dictionary.html#ga6de59736dc56fcda7e4df30ba10ba0cc">dict_serialize_tuplets()</a> utility. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data of the serialized dictionary </td></tr>
    <tr><td class="paramname">size</td><td>The size of data </td></tr>
    <tr><td class="paramname">context</td><td>The context pointer as passed in to <a class="el" href="group___dictionary.html#ga6de59736dc56fcda7e4df30ba10ba0cc">dict_serialize_tuplets()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___dictionary.html#ga6de59736dc56fcda7e4df30ba10ba0cc" title="Utility function that takes a list of Tuplets from which a dictionary will be serialized, ready to transmit or store. ">dict_serialize_tuplets</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gaafae887a6d07cde8d11885c755b55351"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return values for dictionary write/conversion functions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6"></a>DICT_OK</em>&#160;</td><td class="fielddoc">
<p>The operation returned successfully. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04"></a>DICT_NOT_ENOUGH_STORAGE</em>&#160;</td><td class="fielddoc">
<p>There was not enough backing storage to complete the operation. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2"></a>DICT_INVALID_ARGS</em>&#160;</td><td class="fielddoc">
<p>One or more arguments were invalid or uninitialized. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaafae887a6d07cde8d11885c755b55351ad1c1a2b4398b21aca5d171b47f1b6876"></a>DICT_INTERNAL_INCONSISTENCY</em>&#160;</td><td class="fielddoc">
<p>The lengths and/or count of the dictionary its tuples are inconsistent. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaafae887a6d07cde8d11885c755b55351a613e308b84e2711144a049c512393045"></a>DICT_MALLOC_FAILED</em>&#160;</td><td class="fielddoc">
<p>A requested operation required additional memory to be allocated, but the allocation failed, likely due to insufficient remaining heap memory. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaf164f32d9bda6829f1738ef3fb2c6670"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___dictionary.html#gaf164f32d9bda6829f1738ef3fb2c6670">TupleType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Values representing the type of data that the <code>value</code> field of a <a class="el" href="group___dictionary.html#struct_tuple" title="Data structure for one serialized key/value tuple. ">Tuple</a> contains. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggaf164f32d9bda6829f1738ef3fb2c6670ad852031b350c69166303a05dbe294ec7"></a>TUPLE_BYTE_ARRAY</em>&#160;</td><td class="fielddoc">
<p>The value is an array of bytes. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaf164f32d9bda6829f1738ef3fb2c6670a73c9d3384801aec20d36c732d9218dab"></a>TUPLE_CSTRING</em>&#160;</td><td class="fielddoc">
<p>The value is a zero-terminated, UTF-8 C-string. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaf164f32d9bda6829f1738ef3fb2c6670a6802e5d267fdda619ffb13fc80d873fe"></a>TUPLE_UINT</em>&#160;</td><td class="fielddoc">
<p>The value is an unsigned integer. The tuple's <code>.length</code> field is used to determine the size of the integer (1, 2, or 4 bytes). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaf164f32d9bda6829f1738ef3fb2c6670ad691daf1df77095c1e19fe30b6cea5b4"></a>TUPLE_INT</em>&#160;</td><td class="fielddoc">
<p>The value is a signed integer. The tuple's <code>.length</code> field is used to determine the size of the integer (1, 2, or 4 bytes). </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
</div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Mar 18 2014 13:39:46 for Pebble SDK by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
