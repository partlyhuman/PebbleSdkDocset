<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Pebble SDK: Layers</title>
  <link href='bootstrap.css' media='screen' rel='stylesheet' type='text/css' />
  <link href='pebble-developer.css' media='screen' rel='stylesheet' type='text/css' />
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
  <link href="stylesheet.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-30638158-4']);
    _gaq.push(['_trackPageview']);
    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
</head>
<body>
  <div id="top" ><!-- do not remove this div, it is closed by doxygen! -->
    <div class="navbar navbar-inverse ">
      <div class="navbar-inner">
        <div class="container">
          <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <div class="nav-collapse collapse">
            <ul class="nav">
              <li><a class="first" href="#"><span></span></a></li>
              <li><a href="http://developer.getpebble.com/">Develop for Pebble</a></li>
            </ul>
            <ul class="nav pull-right">
              <li class="doc-nav-searchbox">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</li>
              <li><a href="http://forums.getpebble.com/">Forum</a></li>
              <li><a href="http://developer.getpebble.com/2/api-reference/modules.html">API Documentation</a></li>
              <li><a href="http://developer.getpebble.com/2/">Guides</a></li>
              <li><a href="http://developer.getpebble.com/blog/">Developer Blog</a></li>
            </ul>
          </div>
        </div>
      </div>
    </div>
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___layer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<div class="title">Layers<div class="ingroups"><a class="el" href="group___u_i.html">User Interface</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>User interface layers for displaying graphic components. </p>
<p>Layers are objects that can be displayed on a Pebble watchapp window, enabling users to see visual objects, like text or images. Each layer stores the information about its state necessary to draw or redraw the object that it represents and uses graphics routines along with this state to draw itself when asked. Layers can be used to display various graphics.</p>
<p>Layers are the basic building blocks for your application UI. Layers can be nested inside each other. Every window has a root layer which is always the topmost layer. You provide a function that is called to draw the content of the layer when needed; or you can use standard layers that are provided by the system, such as text layer, image layer, menu layer, action bar layer, and so on.</p>
<p>The Pebble layer hierarchy is the list of things that need to be drawn to the screen. Multiple layers can be arranged into a hierarchy. This enables ordering (front to back), layout and hierarchy. Through relative positioning, visual objects that are grouped together by adding them into the same layer can be moved all at once. This means that the child layers will move accordingly. If a parent layer has clipping enabled, all the children will be clipped to the frame of the parent.</p>
<p>Pebble OS provides convenience layers with built-in logic for displaying different graphic components, like text and bitmap layers.</p>
<p>Refer to the <a href="http://developer.getpebble.com/2/guides/ui-framework.html">Building User Interfaces chapter in Pebble Developer Guide</a>
 (chapter "Layers") for a conceptual overview of Layers and relevant code examples.</p>
<p>The Modules listed here contain what can be thought of conceptually as subclasses of Layer. The listed types can be safely type-casted to <code>Layer</code> (or <code>Layer *</code> in case of a pointer). The <code>layer_...</code> functions can then be used with the data structures of these subclasses. <br/>
For example, the following is legal: </p>
<div class="fragment"><div class="line">TextLayer *text_layer;</div>
<div class="line">...</div>
<div class="line">layer_set_hidden((Layer *)text_layer, <span class="keyword">true</span>);</div>
</div><!-- fragment --> <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___action_bar_layer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___action_bar_layer.html">ActionBarLayer</a></td></tr>
<tr class="memdesc:group___action_bar_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertical, bar-shaped control widget on the right edge of the window. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___bitmap_layer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___bitmap_layer.html">BitmapLayer</a></td></tr>
<tr class="memdesc:group___bitmap_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer that displays a bitmap image. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___inverter_layer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___inverter_layer.html">InverterLayer</a></td></tr>
<tr class="memdesc:group___inverter_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer that inverts anything "below it". <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___menu_layer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___menu_layer.html">MenuLayer</a></td></tr>
<tr class="memdesc:group___menu_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer that displays a standard list menu. Data is provided using callbacks. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___rot_bitmap_layer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___rot_bitmap_layer.html">RotBitmapLayer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___scroll_layer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___scroll_layer.html">ScrollLayer</a></td></tr>
<tr class="memdesc:group___scroll_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer that scrolls its contents, animated. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___simple_menu_layer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___simple_menu_layer.html">SimpleMenuLayer</a></td></tr>
<tr class="memdesc:group___simple_menu_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around <a class="el" href="group___menu_layer.html">MenuLayer</a>, that uses static data to display a list menu. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___text_layer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___text_layer.html">TextLayer</a></td></tr>
<tr class="memdesc:group___text_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer that displays and formats a text string. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga282c3ba9878e23bfa19033a9487fdac1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layer_add_child </td>
          <td>(</td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the child layer to a given parent layer, making it appear in front of its parent and in front of any existing child layers of the parent. If the child layer was already part of a layer hierarchy, it will be removed from its old parent first. If added successfully, the parent (and children) will be marked dirty automatically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The layer to which to add the child layer </td></tr>
    <tr><td class="paramname">child</td><td>The layer to add to the parent layer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa14dfd196c850be588b1ab30804690c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Layer* layer_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a>&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a layer on the heap and sets its frame and bounds. Default values: </p>
<ul>
<li><code>bounds</code> : origin (0, 0) and a size equal to the frame that is passed in.</li>
<li><code>clips</code> : <code>true</code></li>
<li><code>hidden</code> : <code>false</code></li>
<li><code>update_proc</code> : <code>NULL</code> (draws nothing) <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The frame at which the layer should be initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___layer.html#ga5a984a17781b97ce00ae34c437171934">layer_set_frame()</a> </dd>
<dd>
<a class="el" href="group___layer.html#ga0a99dca38b75b52264c0734b934c865c">layer_set_bounds()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the layer. <code>NULL</code> if the layer could not be created </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga5bf50fa0daaf1e3c8ded4bc15d25f199"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Layer* layer_create_with_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a>&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___standard_memory.html#ga7b60c5629e55e8ec87a4547dd4abced4">size_t</a>&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a layer on the heap with extra space for callback data, and set its frame andbounds. Default values: </p>
<ul>
<li><code>bounds</code> : origin (0, 0) and a size equal to the frame that is passed in.</li>
<li><code>clips</code> : <code>true</code></li>
<li><code>hidden</code> : <code>false</code></li>
<li><code>update_proc</code> : <code>NULL</code> (draws nothing) <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The frame at which the layer should be initialized. </td></tr>
    <tr><td class="paramname">data_size</td><td>The size (in bytes) of memory to allocate for callback data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___layer.html#gaa14dfd196c850be588b1ab30804690c0">layer_create()</a> </dd>
<dd>
<a class="el" href="group___layer.html#ga5a984a17781b97ce00ae34c437171934">layer_set_frame()</a> </dd>
<dd>
<a class="el" href="group___layer.html#ga0a99dca38b75b52264c0734b934c865c">layer_set_bounds()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the layer. <code>NULL</code> if the layer could not be created </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="gab989ba5a74d4bce391bd1d343673e946"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layer_destroy </td>
          <td>(</td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a layer previously created by layer_create. </p>

</div>
</div>
<a class="anchor" id="ga3e99442ac9d3af36ec7c25118360710c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> layer_get_bounds </td>
          <td>(</td>
          <td class="paramtype">const Layer *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the bounds of the layer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer for which to get the bounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bounds of the layer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___layer.html#ga0a99dca38b75b52264c0734b934c865c" title="Sets the bounds of the layer, which is it&#39;s bounding box relative to its frame. If the bounds has cha...">layer_set_bounds</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga459ca188ae94ee1cd59e691e5fcefaec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool layer_get_clips </td>
          <td>(</td>
          <td class="paramtype">const Layer *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets whether clipping is enabled for the layer. If enabled, whatever the layer <em>and its children</em> will draw using their <code>.update_proc</code> callbacks, will be clipped by the this layer's frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer for which to get the clipping property </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if clipping is enabled for the layer, false if clipping is not enabled for the layer. </dd></dl>

</div>
</div>
<a class="anchor" id="gabcd3dcaaa0f8b4bcae09ffcde21e3d13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* layer_get_data </td>
          <td>(</td>
          <td class="paramtype">const Layer *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the data from a layer that has been created with an extra data region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer to get the data region from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A void pointer to the data region. </dd></dl>

</div>
</div>
<a class="anchor" id="ga76ed01d3619150b87604ebaa9dc282b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a> layer_get_frame </td>
          <td>(</td>
          <td class="paramtype">const Layer *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the frame of the layer, which is it's bounding box relative to the coordinate system of its parent layer. If the frame has changed, <a class="el" href="group___layer.html#ga00bc895642aa02ae2d224659529382c8">layer_mark_dirty()</a> will be called automatically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer for which to get the frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The frame of the layer </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___layer.html#ga5a984a17781b97ce00ae34c437171934" title="Sets the frame of the layer, which is it&#39;s bounding box relative to the coordinate system of its pare...">layer_set_frame</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b4eb514c69ad32fe5cc0f8b3ab9b9b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool layer_get_hidden </td>
          <td>(</td>
          <td class="paramtype">const Layer *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the visibility of the layer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer for which to get the visibility </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the layer is hidden, false if it is not hidden. </dd></dl>

</div>
</div>
<a class="anchor" id="gab9f13c7bbffb949929d7dfe64ba44915"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Window* layer_get_window </td>
          <td>(</td>
          <td class="paramtype">const Layer *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the window that the layer is currently attached to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer for which to get the window </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The window that this layer is currently attached to, or <code>NULL</code> if it has not been added to a window's layer hierarchy. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___window.html#ga8a0233aa7927ebc51a0b2d8708f52fe0">window_get_root_layer()</a> </dd>
<dd>
<a class="el" href="group___layer.html#ga282c3ba9878e23bfa19033a9487fdac1">layer_add_child()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaad290a2abb7f0a37516bb7a45f4157db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layer_insert_above_sibling </td>
          <td>(</td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>layer_to_insert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>above_sibling_layer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the layer as a sibling in front of another layer. The above_layer has to be a child of a parent layer, otherwise this function will be a noop. If inserted successfully, the parent (and children) will be marked dirty automatically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer_to_insert</td><td>The layer to insert into the hierarchy </td></tr>
    <tr><td class="paramname">above_sibling_layer</td><td>The layer that will be used as the sibling layer below which the insertion will take place </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf838c6113463f2924f50be98e15231e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layer_insert_below_sibling </td>
          <td>(</td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>layer_to_insert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>below_sibling_layer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the layer as a sibling behind another layer. The below_layer has to be a child of a parent layer, otherwise this function will be a noop. If inserted successfully, the parent (and children) will be marked dirty automatically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer_to_insert</td><td>The layer to insert into the hierarchy </td></tr>
    <tr><td class="paramname">below_sibling_layer</td><td>The layer that will be used as the sibling layer above which the insertion will take place </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga00bc895642aa02ae2d224659529382c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layer_mark_dirty </td>
          <td>(</td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks the complete layer as "dirty", awaiting to be asked by the system to redraw itself. Typically, this function is called whenever state has changed that affects what the layer is displaying. </p>
<ul>
<li>The layer's <code>.update_proc</code> will not be called before this function returns, but will be called asynchronously, shortly.</li>
<li>Internally, a call to this function will schedule a re-render of the window that the layer belongs to. In effect, all layers in that window's layer hierarchy will be asked to redraw.</li>
<li>If an earlier re-render request is still pending, this function is a no-op. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer to mark dirty </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ga20bc62c736890f73edd0a4381219950f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layer_remove_child_layers </td>
          <td>(</td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes child layers from given layer If removed successfully, the child's parent layer will be marked dirty automatically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The layer from which to remove all child layers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga15574128ca92653c64d164f6f13e2361"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layer_remove_from_parent </td>
          <td>(</td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the layer from its current parent layer If removed successfully, the child's parent layer will be marked dirty automatically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>The layer to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0a99dca38b75b52264c0734b934c865c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layer_set_bounds </td>
          <td>(</td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a>&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the bounds of the layer, which is it's bounding box relative to its frame. If the bounds has changed, <a class="el" href="group___layer.html#ga00bc895642aa02ae2d224659529382c8">layer_mark_dirty()</a> will be called automatically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer for which to set the bounds </td></tr>
    <tr><td class="paramname">bounds</td><td>The new bounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___layer.html#ga5a984a17781b97ce00ae34c437171934">layer_set_frame()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0e7f5b5a70fceadc6245974306b11025"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layer_set_clips </td>
          <td>(</td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clips</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether clipping is enabled for the layer. If enabled, whatever the layer <em>and its children</em> will draw using their <code>.update_proc</code> callbacks, will be clipped by the this layer's frame. If the clipping has changed, <a class="el" href="group___layer.html#ga00bc895642aa02ae2d224659529382c8">layer_mark_dirty()</a> will be called automatically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer for which to set the clipping property </td></tr>
    <tr><td class="paramname">clips</td><td>Supply <code>true</code> to make the layer clip to its frame, or <code>false</code> to make it non-clipping. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5a984a17781b97ce00ae34c437171934"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layer_set_frame </td>
          <td>(</td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___graphics_types.html#struct_g_rect">GRect</a>&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the frame of the layer, which is it's bounding box relative to the coordinate system of its parent layer. The size of the layer's bounds will be extended automatically, so that the bounds cover the new frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer for which to set the frame </td></tr>
    <tr><td class="paramname">frame</td><td>The new frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___layer.html#ga0a99dca38b75b52264c0734b934c865c">layer_set_bounds()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac267ce4cc84b0f39297b56edf5ca4b48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layer_set_hidden </td>
          <td>(</td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hidden</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the visibility of the layer. If the visibility has changed, <a class="el" href="group___layer.html#ga00bc895642aa02ae2d224659529382c8">layer_mark_dirty()</a> will be called automatically on the parent layer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer for which to set the visibility </td></tr>
    <tr><td class="paramname">hidden</td><td>Supply <code>true</code> to make the layer hidden, or <code>false</code> to make it non-hidden. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga57eddbe4fe47beefadeaf775a3c8dcaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layer_set_update_proc </td>
          <td>(</td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___layer.html#ga5bf7c903e32df0edcb1ec0b23d367bf0">LayerUpdateProc</a>&#160;</td>
          <td class="paramname"><em>update_proc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the layer's render function. The system will call the <code>update_proc</code> automatically when the layer needs to redraw itself, see also <a class="el" href="group___layer.html#ga00bc895642aa02ae2d224659529382c8">layer_mark_dirty()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>Pointer to the layer structure. </td></tr>
    <tr><td class="paramname">update_proc</td><td>Pointer to the function that will be called when the layer needs to be rendered. Typically, one performs a series of drawing commands in the implementation of the <code>update_proc</code>, see <a class="el" href="group___drawing.html">Drawing Primitives</a>, <a class="el" href="group___path_drawing.html">Drawing Paths</a> and <a class="el" href="group___text_drawing.html">Drawing Text</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga5bf7c903e32df0edcb1ec0b23d367bf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* LayerUpdateProc)(struct Layer *layer, GContext *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function signature for a Layer's render callback (the name of the type is derived from the words 'update procedure'). The system will call the <code>.update_proc</code> callback whenever the Layer needs to be rendered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer that needs to be rendered </td></tr>
    <tr><td class="paramname">ctx</td><td>The destination graphics context to draw into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___graphics.html">Graphics</a> </dd>
<dd>
<a class="el" href="group___layer.html#ga57eddbe4fe47beefadeaf775a3c8dcaa">layer_set_update_proc()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
</div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Dec 12 2013 18:41:22 for Pebble SDK by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
